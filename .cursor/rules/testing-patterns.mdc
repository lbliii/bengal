---
globs: tests/**/*.py
description: Testing patterns and best practices for Bengal test suite
---

# Testing Patterns for Bengal

Bengal has a comprehensive testing infrastructure designed for ergonomic and maintainable tests.

## Quick Reference

### Integration Tests with @pytest.mark.bengal

```python
import pytest

@pytest.mark.bengal(testroot="test-basic")
def test_simple_build(site, build_site):
    """Test basic site building."""
    # site is pre-configured from test-basic root
    build_site()

    assert len(site.pages) == 1
    assert (site.output_dir / "index.html").exists()


@pytest.mark.bengal(
    testroot="test-baseurl",
    confoverrides={"site.baseurl": "/custom"}
)
def test_custom_config(site):
    """Test with config overrides."""
    assert site.baseurl == "/custom"
```

**Available test roots** (from `tests/roots/`):
- `test-basic` - Minimal 1-page site
- `test-baseurl` - Tests baseurl handling
- `test-taxonomy` - 3 pages with tags
- `test-templates` - Template examples
- `test-assets` - Custom + theme assets
- `test-cascade` - Nested sections with cascade

See: [tests/roots/README.md](mdc:tests/roots/README.md)

### CLI Testing

```python
from tests._testing.cli import run_cli

def test_version_command():
    """Test version command."""
    result = run_cli(["--version"])

    # Assertions
    result.assert_ok()  # returncode == 0
    assert "Bengal" in result.stdout


def test_build_failure():
    """Test build command with invalid site."""
    result = run_cli(["site", "build"], cwd="/nonexistent")

    result.assert_fail_with()  # returncode != 0
    result.assert_stderr_contains("not found")
```

### Output Normalization

Use normalization for deterministic assertions:

```python
from tests._testing.normalize import normalize_html, normalize_json

def test_asset_hashing(site, build_site):
    """Test asset hashing in output."""
    build_site()
    html = (site.output_dir / "index.html").read_text()

    # Normalize volatile elements (paths, hashes, timestamps)
    norm_html = normalize_html(html)

    # Assert on stable patterns
    assert 'href="/assets/css/style.HASH.css"' in norm_html
```

## Test Organization

### Directory Structure

```
tests/
├── unit/              # Fast, isolated component tests
│   ├── test_page.py
│   ├── test_site.py
│   └── ...
├── integration/       # Multi-component workflow tests
│   ├── test_build_workflow.py
│   ├── test_incremental_build.py
│   └── ...
├── performance/       # Performance benchmarks
│   ├── test_parallel_rendering.py
│   └── ...
├── roots/            # Reusable test site fixtures
│   ├── test-basic/
│   ├── test-taxonomy/
│   └── ...
└── _testing/         # Shared test utilities
    ├── fixtures.py
    ├── markers.py
    ├── cli.py
    └── normalize.py
```

### When to Use Each

**Unit Tests** (`tests/unit/`):
- Fast (< 1 second)
- Test single function/class
- No file I/O if possible
- Mock external dependencies

**Integration Tests** (`tests/integration/`):
- Test multiple components together
- Use real file I/O
- Use test roots for site setup
- Test end-to-end workflows

**Performance Tests** (`tests/performance/`):
- Benchmark critical paths
- Use `@pytest.mark.slow`
- Document baseline performance

## Test Naming

```python
# ✅ CORRECT - Descriptive: test_<what>_<when>_<expected>
def test_page_render_with_custom_template_uses_custom():
    pass

def test_build_incremental_when_file_unchanged_skips_render():
    pass

def test_taxonomy_index_with_no_tags_returns_empty():
    pass

# ❌ WRONG - Too vague
def test_page():
    pass

def test_build():
    pass
```

## Test Structure (Arrange-Act-Assert)

```python
def test_page_extracts_title_from_frontmatter():
    # Arrange - Set up test data
    content = """---
title: My Post
---
Content here"""

    # Act - Perform the operation
    page = Page.from_content(Path("test.md"), content)

    # Assert - Verify results
    assert page.title == "My Post"
```

## Pytest Markers

```python
# Slow tests (>5 seconds per test)
@pytest.mark.slow
def test_large_site_build():
    pass

# Property-based tests
@pytest.mark.hypothesis
def test_page_title_always_string(title_str):
    pass

# Must run sequentially (not parallelizable)
@pytest.mark.serial
def test_cache_file_locking():
    pass

# Integration tests
@pytest.mark.integration
def test_full_build_workflow():
    pass

# Requires internet
@pytest.mark.network
def test_link_checker_external():
    pass
```

**Running tests with markers**:

```bash
# Fast feedback - skip slow tests
pytest -m "not slow" -n auto

# Full suite
pytest -n auto

# Only slow tests
pytest -m slow

# Only integration tests
pytest -m integration
```

## Using Test Roots

Don't create duplicate test sites - use test roots:

```python
# ✅ CORRECT - Reuse test root
@pytest.mark.bengal(testroot="test-taxonomy")
def test_tag_pages_generated(site, build_site):
    build_site()
    assert (site.output_dir / "tags" / "python" / "index.html").exists()

# ❌ WRONG - Creating custom test site each time
def test_tag_pages_generated(tmp_path):
    # Don't do this - creates duplicate fixture
    content_dir = tmp_path / "content"
    content_dir.mkdir()
    (content_dir / "post.md").write_text("---\ntags: [python]\n---\nContent")
    # ... more setup ...
```

## Fixtures

### Common Fixtures

```python
# From tests/_testing/fixtures.py
def test_with_site_factory(site_factory):
    """Create custom site."""
    site = site_factory("test-basic", confoverrides={"site.title": "Custom"})
    assert site.title == "Custom"


def test_with_build_helper(site, build_site):
    """Use build helper."""
    build_site()  # Convenience wrapper
    assert len(site.pages) > 0
```

### Creating Custom Fixtures

```python
# In your test file or conftest.py
import pytest

@pytest.fixture
def sample_page(tmp_path):
    """Create a sample page for testing."""
    content = """---
title: Test Page
date: 2025-01-01
---
# Heading

Content here.
"""
    file_path = tmp_path / "test.md"
    file_path.write_text(content)
    return file_path
```

## Assertions

### Use Specific Assertions

```python
# ✅ CORRECT - Specific assertions
assert page.title == "My Post"
assert len(site.pages) == 5
assert output_path.exists()
assert "error" in result.stderr.lower()

# ❌ WRONG - Generic assertions
assert page  # What are we checking?
assert site  # Too vague
```

### Multiple Assertions OK

```python
# ✅ CORRECT - Multiple related assertions in one test
def test_page_metadata_extracted():
    page = create_test_page()

    # All related to metadata extraction
    assert page.title == "My Post"
    assert page.date == datetime(2025, 1, 1)
    assert page.tags == ["python", "web"]
```

## Test Coverage

**Coverage goals**:
- Unit tests: >90% coverage
- Critical paths: 100% coverage
- Edge cases: Document if not covered

**Running with coverage**:

```bash
# Generate coverage report
pytest --cov=bengal --cov-report=html

# View report
open htmlcov/index.html
```

## Performance Testing

```python
import pytest

@pytest.mark.slow
def test_parallel_rendering_performance(benchmark, site_factory):
    """Benchmark parallel rendering."""
    site = site_factory("test-large")

    # Benchmark the build
    result = benchmark(site.build)

    # Assert performance threshold
    assert result < 5.0  # Must complete in <5 seconds
```

## Common Patterns

### Testing Exceptions

```python
def test_invalid_config_raises():
    """Test that invalid config raises appropriate error."""
    with pytest.raises(ValueError, match="Invalid baseurl"):
        Site.from_config(Path("."), {"site": {"baseurl": "no-leading-slash"}})
```

### Testing File Output

```python
def test_generated_html_structure(site, build_site):
    """Test generated HTML has correct structure."""
    build_site()

    html = (site.output_dir / "index.html").read_text()

    # Use BeautifulSoup for HTML parsing in tests
    from bs4 import BeautifulSoup
    soup = BeautifulSoup(html, 'html.parser')

    assert soup.find('h1').text == "Welcome"
    assert soup.find('nav') is not None
```

### Parametrized Tests

```python
@pytest.mark.parametrize("parser_engine,expected_output", [
    ("mistune", "<p>Hello</p>"),
    ("python-markdown", "<p>Hello</p>"),
])
def test_markdown_parsing(parser_engine, expected_output):
    """Test different markdown parsers."""
    result = parse_markdown("Hello", engine=parser_engine)
    assert result.strip() == expected_output
```

## Best Practices

1. **One concept per test** - Test one behavior at a time
2. **Fast by default** - Keep unit tests under 1 second
3. **Reuse test roots** - Don't duplicate fixtures
4. **Normalize output** - Use helpers for deterministic assertions
5. **Clear names** - Test name should describe what's being tested
6. **Arrange-Act-Assert** - Follow the pattern consistently
7. **Test both success and failure** - Happy path and error cases

## Related Files

- [tests/_testing/README.md](mdc:tests/_testing/README.md) - Testing utilities
- [tests/roots/README.md](mdc:tests/roots/README.md) - Test root documentation
- [CONTRIBUTING.md](mdc:CONTRIBUTING.md) - Testing guidelines
- [TESTING_STRATEGY.md](mdc:TESTING_STRATEGY.md) - Overall testing strategy
