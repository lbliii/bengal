"""
Tests for section archive page URL generation.

Section orchestrator auto-generates archive pages for sections without _index.md.
These archives need to link to child pages with correct URLs.

Critical scenarios:
- Auto-generated archives
- Archive pagination
- Archives with cascaded types
- Archives with mixed content
"""

from pathlib import Path
from tempfile import TemporaryDirectory

import pytest

from bengal.core.site import Site
from bengal.orchestration.content import ContentOrchestrator
from bengal.orchestration.section import SectionOrchestrator


class TestAutoGeneratedArchives:
    """Test archives auto-generated by section orchestrator."""

    @pytest.fixture
    def site_without_index(self):
        """Create site with section but no _index.md."""
        with TemporaryDirectory() as tmpdir:
            root = Path(tmpdir)
            blog_dir = root / "content" / "blog"
            blog_dir.mkdir(parents=True, exist_ok=True)

            # NO _index.md - should get auto-generated archive
            (blog_dir / "post-1.md").write_text("---\ntitle: Post 1\ndate: 2024-01-01\n---")
            (blog_dir / "post-2.md").write_text("---\ntitle: Post 2\ndate: 2024-01-02\n---")
            (blog_dir / "post-3.md").write_text("---\ntitle: Post 3\ndate: 2024-01-03\n---")

            site = Site(root_path=root, config={})
            yield site

    def test_auto_archive_created(self, site_without_index):
        """Section orchestrator should create archive for section without index."""
        content_orch = ContentOrchestrator(site_without_index)
        content_orch.discover()

        section_orch = SectionOrchestrator(site_without_index)
        section_orch.finalize_sections()

        # Find blog section
        blog_section = [s for s in site_without_index.sections if s.name == "blog"][0]

        # Should have auto-generated index page
        assert blog_section.index_page is not None, "Archive should be auto-generated"
        assert blog_section.index_page.metadata.get("_generated"), "Should be marked generated"

    def test_auto_archive_child_urls(self, site_without_index):
        """Auto-generated archive should have access to child pages with correct URLs."""
        content_orch = ContentOrchestrator(site_without_index)
        content_orch.discover()

        section_orch = SectionOrchestrator(site_without_index)
        section_orch.finalize_sections()

        blog_section = [s for s in site_without_index.sections if s.name == "blog"][0]

        # Get child posts (not the index)
        posts = [p for p in blog_section.pages if not p.metadata.get("_generated")]

        assert len(posts) >= 3, "Should have 3 blog posts"

        # All posts should have /blog/ prefix
        for post in posts:
            assert post.url.startswith("/blog/"), f"Archive child post wrong URL: {post.url}"

    def test_archive_metadata_posts_list(self, site_without_index):
        """Archive metadata should contain _posts list with correct URLs."""
        content_orch = ContentOrchestrator(site_without_index)
        content_orch.discover()

        section_orch = SectionOrchestrator(site_without_index)
        section_orch.finalize_sections()

        blog_section = [s for s in site_without_index.sections if s.name == "blog"][0]
        archive = blog_section.index_page

        # Archive should have _posts in metadata
        posts_list = archive.metadata.get("_posts", [])
        assert len(posts_list) >= 3, "Archive should have posts list"

        # Check URLs in posts list
        for post in posts_list:
            assert post.url.startswith("/blog/"), f"Archive post list wrong URL: {post.url}"


class TestArchivePagination:
    """Test paginated archive URLs."""

    @pytest.fixture
    def large_section_site(self):
        """Create site with many posts requiring pagination."""
        with TemporaryDirectory() as tmpdir:
            root = Path(tmpdir)
            blog_dir = root / "content" / "blog"
            blog_dir.mkdir(parents=True, exist_ok=True)

            # Create many posts
            for i in range(1, 16):
                (blog_dir / f"post-{i:02d}.md").write_text(
                    f"---\ntitle: Post {i}\ndate: 2024-01-{i:02d}\n---"
                )

            site = Site(root_path=root, config={"pagination": {"per_page": 5}})
            yield site

    def test_paginated_posts_have_correct_urls(self, large_section_site):
        """All posts in paginated archives should have correct section prefix."""
        content_orch = ContentOrchestrator(large_section_site)
        content_orch.discover()

        # All posts should have URLs with /blog/ prefix
        posts = [
            p
            for p in large_section_site.pages
            if "blog" in str(p.source_path) and not p.metadata.get("_generated")
        ]

        assert len(posts) >= 15

        for post in posts:
            assert post.url.startswith("/blog/"), f"Paginated post wrong URL: {post.url}"


class TestArchiveWithCascade:
    """Test archives with cascaded content type."""

    @pytest.fixture
    def cascaded_archive_site(self):
        """Create site with section that has cascade but no _index.md initially."""
        with TemporaryDirectory() as tmpdir:
            root = Path(tmpdir)

            # Create parent with cascade
            docs_dir = root / "content" / "docs"
            docs_dir.mkdir(parents=True, exist_ok=True)
            (docs_dir / "_index.md").write_text(
                "---\ntitle: Docs\ntype: doc\ncascade:\n  type: doc\n---"
            )

            # Create subsection WITHOUT _index.md
            guides_dir = docs_dir / "guides"
            guides_dir.mkdir(parents=True, exist_ok=True)
            (guides_dir / "guide-1.md").write_text("---\ntitle: Guide 1\n---")
            (guides_dir / "guide-2.md").write_text("---\ntitle: Guide 2\n---")

            site = Site(root_path=root, config={})
            yield site

    def test_cascaded_archive_child_urls(self, cascaded_archive_site):
        """Archives with cascaded types should preserve child URLs."""
        content_orch = ContentOrchestrator(cascaded_archive_site)
        content_orch.discover()

        section_orch = SectionOrchestrator(cascaded_archive_site)
        section_orch.finalize_sections()

        # Find guides (should have auto-generated archive with cascaded type)
        guides = [p for p in cascaded_archive_site.pages if "guides/guide-" in str(p.source_path)]

        assert len(guides) >= 2

        # All should have full path /docs/guides/
        for guide in guides:
            assert guide.url.startswith(
                "/docs/guides/"
            ), f"Cascaded archive child wrong URL: {guide.url}"
            # Type should be cascaded
            assert guide.metadata.get("type") == "doc"


class TestNestedArchives:
    """Test archives in nested section hierarchies."""

    @pytest.fixture
    def nested_archive_site(self):
        """Create deeply nested sections with archives."""
        with TemporaryDirectory() as tmpdir:
            root = Path(tmpdir)

            # Create: api/v2/endpoints (all without _index.md)
            endpoints_dir = root / "content" / "api" / "v2" / "endpoints"
            endpoints_dir.mkdir(parents=True, exist_ok=True)

            (endpoints_dir / "users.md").write_text("---\ntitle: Users API\n---")
            (endpoints_dir / "posts.md").write_text("---\ntitle: Posts API\n---")

            site = Site(root_path=root, config={})
            yield site

    def test_deeply_nested_archive_urls(self, nested_archive_site):
        """Deeply nested archives should maintain full path hierarchy."""
        content_orch = ContentOrchestrator(nested_archive_site)
        content_orch.discover()

        section_orch = SectionOrchestrator(nested_archive_site)
        section_orch.finalize_sections()

        # Find endpoint pages
        endpoints = [
            p for p in nested_archive_site.pages if p.source_path.stem in ("users", "posts")
        ]

        assert len(endpoints) >= 2

        for endpoint in endpoints:
            assert endpoint.url.startswith(
                "/api/v2/endpoints/"
            ), f"Nested archive child wrong URL: {endpoint.url}"


class TestMixedArchiveContent:
    """Test archives with mixed content types and structures."""

    @pytest.fixture
    def mixed_archive_site(self):
        """Create section with both _index.md sections and auto-archive sections."""
        with TemporaryDirectory() as tmpdir:
            root = Path(tmpdir)
            content_dir = root / "content" / "mixed"
            content_dir.mkdir(parents=True, exist_ok=True)

            # Root has _index.md
            (content_dir / "_index.md").write_text("---\ntitle: Mixed\n---")
            (content_dir / "page-1.md").write_text("---\ntitle: Page 1\n---")

            # Subsection WITH _index.md
            with_index = content_dir / "with-index"
            with_index.mkdir(parents=True, exist_ok=True)
            (with_index / "_index.md").write_text("---\ntitle: With Index\n---")
            (with_index / "sub-page.md").write_text("---\ntitle: Sub Page\n---")

            # Subsection WITHOUT _index.md (gets archive)
            without_index = content_dir / "without-index"
            without_index.mkdir(parents=True, exist_ok=True)
            (without_index / "auto-page.md").write_text("---\ntitle: Auto Page\n---")

            site = Site(root_path=root, config={})
            yield site

    def test_mixed_sections_all_urls_correct(self, mixed_archive_site):
        """Both manual and auto-generated sections should have correct URLs."""
        content_orch = ContentOrchestrator(mixed_archive_site)
        content_orch.discover()

        section_orch = SectionOrchestrator(mixed_archive_site)
        section_orch.finalize_sections()

        # Collect all pages
        all_pages = mixed_archive_site.pages

        # Group by section
        for page in all_pages:
            path_str = str(page.source_path)

            if "mixed" not in path_str:
                continue

            # Check each subsection
            if "with-index" in path_str:
                assert page.url.startswith(
                    "/mixed/with-index/"
                ), f"Manual section wrong URL: {page.url}"
            elif "without-index" in path_str:
                assert page.url.startswith(
                    "/mixed/without-index/"
                ), f"Auto-archive section wrong URL: {page.url}"
            elif page.source_path.stem == "page-1":
                assert page.url.startswith("/mixed/"), f"Root section page wrong URL: {page.url}"


class TestArchiveURLConsistency:
    """Test URL consistency between archive and regular pages."""

    def test_archive_and_manual_index_same_behavior(self):
        """Auto-archive and manual _index.md should produce same child URLs."""
        with TemporaryDirectory() as tmpdir:
            root = Path(tmpdir)

            # Section A: with _index.md
            section_a = root / "content" / "section-a"
            section_a.mkdir(parents=True, exist_ok=True)
            (section_a / "_index.md").write_text("---\ntitle: Section A\n---")
            (section_a / "page.md").write_text("---\ntitle: Page A\n---")

            # Section B: without _index.md (gets archive)
            section_b = root / "content" / "section-b"
            section_b.mkdir(parents=True, exist_ok=True)
            (section_b / "page.md").write_text("---\ntitle: Page B\n---")

            site = Site(root_path=root, config={})
            content_orch = ContentOrchestrator(site)
            content_orch.discover()

            section_orch = SectionOrchestrator(site)
            section_orch.finalize_sections()

            # Find pages
            page_a = [p for p in site.pages if "section-a/page" in str(p.source_path)][0]
            page_b = [p for p in site.pages if "section-b/page" in str(p.source_path)][0]

            # Both should follow same URL pattern
            assert page_a.url == "/section-a/page/", f"Manual index page wrong: {page_a.url}"
            assert page_b.url == "/section-b/page/", f"Auto-archive page wrong: {page_b.url}"
