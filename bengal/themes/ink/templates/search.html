{% extends "base.html" %}
{#
================================================================================
INK THEME - Search Page (Kida-Native)
================================================================================
Simple search page with inline results.

KIDA FEATURES USED:
- {% let %} multi-let for grouped config access
- Optional chaining (?.) for safe access
- Null coalescing (??) for fallback values
================================================================================
#}

{# Multi-let for search config #}
{% let
_placeholder = config?.search?.placeholder ?? 'Type to search...',
_min_chars = config?.search?.min_chars ?? 2,
_site_title = config?.title ?? 'Site' %}

{% block title %}Search â€” {{ _site_title }}{% end %}

{% block content %}
<div class="container">
    <article class="content">
        <header class="page-header">
            <h1 class="page-title">Search</h1>
        </header>

        <div class="search-page">
            <div class="search-input-wrapper">
                <input type="search" id="search-input" class="search-input" placeholder="{{ _placeholder }}"
                    autocomplete="off" autofocus data-min-chars="{{ _min_chars }}">
            </div>

            <div id="search-results" class="search-results">
                <p class="search-hint">Start typing to search the documentation.</p>
            </div>
        </div>
    </article>
</div>

<style>
    .search-input-wrapper {
        margin-block-end: var(--space-8);
    }

    .search-input {
        width: 100%;
        padding: var(--space-4);
        font-family: var(--font-body);
        font-size: var(--text-lg);
        color: var(--color-text-primary);
        background: var(--color-bg-secondary);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
    }

    .search-input:focus {
        outline: 2px solid var(--color-accent);
        outline-offset: 2px;
    }

    .search-hint {
        color: var(--color-text-muted);
        font-style: italic;
    }

    .search-result {
        padding-block: var(--space-4);
        border-block-end: 1px solid var(--color-border-light);
    }

    .search-result:last-child {
        border-block-end: none;
    }

    .search-result h3 {
        font-size: var(--text-lg);
        margin: 0 0 var(--space-2) 0;
    }

    .search-result h3 a {
        color: var(--color-text-primary);
        text-decoration: none;
    }

    .search-result h3 a:hover {
        color: var(--color-accent);
    }

    .search-result p {
        font-size: var(--text-sm);
        color: var(--color-text-secondary);
        margin: 0;
    }

    .search-result mark {
        background: var(--color-accent-light);
        color: inherit;
    }

    .search-no-results {
        color: var(--color-text-muted);
        font-style: italic;
    }
</style>
{% end %}

{% block extra_js %}
<script src="{{ asset_url('js/vendor/lunr.min.js') }}" defer></script>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const input = document.getElementById('search-input');
        const results = document.getElementById('search-results');
        const minChars = parseInt(input?.dataset?.minChars ?? '2', 10);
        let index = null;
        let documents = {};

        // Load search index
        fetch('{{ "/index.json" | absolute_url }}')
            .then(response => response.json())
            .then(data => {
                documents = {};
                data.forEach(doc => {
                    documents[doc.url] = doc;
                });

                index = lunr(function () {
                    this.ref('url');
                    this.field('title', { boost: 10 });
                    this.field('content');
                    this.field('tags', { boost: 5 });

                    data.forEach(doc => {
                        this.add(doc);
                    });
                });

                // Check for query in URL
                const params = new URLSearchParams(window.location.search);
                const query = params.get('q');
                if (query) {
                    input.value = query;
                    performSearch(query);
                }
            });

        // Search on input
        input?.addEventListener('input', function (e) {
            const query = e.target.value.trim();
            if (query.length > minChars) {
                performSearch(query);
            } else {
                results.innerHTML = '<p class="search-hint">Start typing to search the documentation.</p>';
            }
        });

        function performSearch(query) {
            if (!index) return;

            const searchResults = index.search(query + '*');

            if (searchResults.length === 0) {
                results.innerHTML = '<p class="search-no-results">No results found for "' + escapeHtml(query) + '"</p>';
                return;
            }

            let html = '';
            searchResults.slice(0, 20).forEach(result => {
                const doc = documents[result.ref];
                if (doc) {
                    const excerpt = getExcerpt(doc.content, query);
                    html += `
                    <div class="search-result">
                        <h3><a href="${doc.url}">${escapeHtml(doc.title)}</a></h3>
                        <p>${excerpt}</p>
                    </div>
                `;
                }
            });

            results.innerHTML = html;
        }

        function getExcerpt(content, query) {
            const words = query.toLowerCase().split(/\s+/);
            const text = content ?? '';
            const lowerText = text.toLowerCase();

            let startIndex = 0;
            for (const word of words) {
                const idx = lowerText.indexOf(word);
                if (idx !== -1) {
                    startIndex = Math.max(0, idx - 50);
                    break;
                }
            }

            let excerpt = text.slice(startIndex, startIndex + 200);
            if (startIndex > 0) excerpt = '...' + excerpt;
            if (startIndex + 200 < text.length) excerpt += '...';

            words.forEach(word => {
                const regex = new RegExp('(' + escapeRegex(word) + ')', 'gi');
                excerpt = excerpt.replace(regex, '<mark>$1</mark>');
            });

            return excerpt;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
    });
</script>
{% end %}
