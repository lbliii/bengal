    def _parse_block_quote(self) -> BlockQuote:
        """Parse block quote (> quoted).

        CommonMark 5.1: Block quotes can contain any block-level content,
        including headings, code blocks, lists, and nested block quotes.
        """
        start_token = self._current
        assert start_token is not None and start_token.type == TokenType.BLOCK_QUOTE_MARKER
        self._advance()

        # Collect content lines
        content_lines: list[str] = []
        last_marker_line: int | None = start_token.location.lineno
        has_paragraph_content = False

        while not self._at_end():
            token = self._current
            assert token is not None

            if token.type == TokenType.PARAGRAPH_LINE:
                if last_marker_line is not None and token.location.lineno != last_marker_line:
                    if not has_paragraph_content:
                        break
                # Use source to preserve exact leading spaces
                line_text = self._source[token.location.offset : token.location.end_offset].rstrip("\n")
                content_lines.append(line_text)
                has_paragraph_content = True
                last_marker_line = None
                self._advance()
            elif token.type == TokenType.BLOCK_QUOTE_MARKER:
                if last_marker_line is not None and token.location.lineno != last_marker_line:
                    # New line with > marker.
                    # If previous was empty marker line, add blank line.
                    if not has_paragraph_content:
                        content_lines.append("")
                last_marker_line = token.location.lineno
                has_paragraph_content = False
                self._advance()
            elif token.type in (
                TokenType.ATX_HEADING,
                TokenType.THEMATIC_BREAK,
                TokenType.FENCED_CODE_START,
                TokenType.LIST_ITEM_MARKER,
                TokenType.HTML_BLOCK,
            ):
                if last_marker_line is not None and token.location.lineno != last_marker_line:
                    break
                line_text = self._source[token.location.offset : token.location.end_offset].rstrip("\n")
                content_lines.append(line_text)
                has_paragraph_content = (token.type == TokenType.LIST_ITEM_MARKER)
                last_marker_line = None
                self._advance()
            elif token.type == TokenType.INDENTED_CODE:
                if last_marker_line is None and has_paragraph_content:
                    # Lazy continuation
                    lazy_content = token.value.rstrip("\n")
                    if lazy_content.lstrip().startswith(("-", "*", "+", ">")):
                        lazy_content = "\x00" + lazy_content
                    content_lines[-1] = content_lines[-1] + "\n" + lazy_content
                    self._advance()
                    continue
                break
            elif token.type == TokenType.BLANK_LINE:
                break
            else:
                break

        # Parse content as blocks using recursive sub-parser
        content = "\n".join(content_lines)
        if content.strip() or any(line == "" for line in content_lines):
            # Use sub-parser to parse nested block content
            children = self._parse_nested_content(content, start_token.location)
            return BlockQuote(location=start_token.location, children=children)

        return BlockQuote(location=start_token.location, children=())
