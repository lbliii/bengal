
---
title: "file_lock"
type: "python-module"
source_file: "bengal/bengal/utils/file_lock.py"
line_number: 1
description: "File locking utilities for concurrent build safety. Provides cross-platform file locking to prevent cache corruption when multiple build processes run simultaneously. On Unix/macOS: Uses fcntl.flock()..."
---

# file_lock
**Type:** Module
**Source:** [View source](bengal/bengal/utils/file_lock.py#L1)



**Navigation:**
[bengal](/api/bengal/) ›[utils](/api/bengal/utils/) ›file_lock

File locking utilities for concurrent build safety.

Provides cross-platform file locking to prevent cache corruption when
multiple build processes run simultaneously.

On Unix/macOS: Uses fcntl.flock()
On Windows: Uses msvcrt.locking()

Example:
    >>> from bengal.utils.file_lock import file_lock
    >>> with file_lock(cache_path, exclusive=True):
    ...     # Safely read/write cache
    ...     cache.save(cache_path)

## Classes




### `LockAcquisitionError`


**Inherits from:**`Exception`Raised when a lock cannot be acquired within the timeout.

## Functions



### `file_lock`


```python
def file_lock(path: Path, exclusive: bool = True, timeout: float = DEFAULT_LOCK_TIMEOUT) -> Generator[None]
```



Context manager for file locking.

Acquires a lock on a .lock file adjacent to the target path.
Uses non-blocking attempts with retry for better timeout control.


**Parameters:**

| Name | Type | Default | Description |
|:-----|:-----|:--------|:------------|
| `path` | `Path` | - | Path to the file to lock (lock file will be path.lock) |
| `exclusive` | `bool` | `True` | If True, acquire exclusive (write) lock; else shared (read) lock |
| `timeout` | `float` | `DEFAULT_LOCK_TIMEOUT` | Maximum seconds to wait for lock (default: 30) |







**Returns**


`Generator[None]`
:::{rubric} Raises
:class: rubric-raises
:::

- **`LockAcquisitionError`**:If lock cannot be acquired within timeout

:::{rubric} Examples
:class: rubric-examples
:::


```python
>>> with file_lock(Path("cache.json"), exclusive=True):
    ...     # Safely write to cache
    ...     data = load_cache()
    ...     save_cache(data)
```





### `is_locked`


```python
def is_locked(path: Path) -> bool
```



Check if a file is currently locked.


**Parameters:**

| Name | Type | Default | Description |
|:-----|:-----|:--------|:------------|
| `path` | `Path` | - | Path to check |







**Returns**


`bool` - True if file appears to be locked by another process




### `remove_stale_lock`


```python
def remove_stale_lock(path: Path, max_age_seconds: float = 3600) -> bool
```



Remove a stale lock file that may have been left by a crashed process.


**Parameters:**

| Name | Type | Default | Description |
|:-----|:-----|:--------|:------------|
| `path` | `Path` | - | Path to the file (not the lock file) |
| `max_age_seconds` | `float` | `3600` | Maximum age in seconds before considering stale |







**Returns**


`bool` - True if stale lock was removed



---
*Generated by Bengal autodoc from `bengal/bengal/utils/file_lock.py`*

