
---
title: "loader"
type: "python-module"
source_file: "bengal/bengal/collections/loader.py"
line_number: 1
description: "Collection loader - loads collection definitions from project files. Discovers and loads collection schemas from the user\'s collections.py file at the project root."
---

# loader
**Type:** Module
**Source:** [View source](bengal/bengal/collections/loader.py#L1)



**Navigation:**
[bengal](/api/bengal/) ›[collections](/api/bengal/collections/) ›loader

Collection loader - loads collection definitions from project files.

Discovers and loads collection schemas from the user's collections.py file
at the project root.

## Functions



### `load_collections`


```python
def load_collections(project_root: Path, collection_file: str = 'collections.py') -> dict[str, CollectionConfig]
```



Load collection definitions from project's collections.py file.

Searches for collections.py in the project root and loads the
`collections` dictionary containing CollectionConfig instances.


**Parameters:**

| Name | Type | Default | Description |
|:-----|:-----|:--------|:------------|
| `project_root` | `Path` | - | Path to project root directory |
| `collection_file` | `str` | `'collections.py'` | Name of collections file (default: collections.py) |







**Returns**


`dict[str, CollectionConfig]` - Dictionary mapping collection names to CollectionConfig instances.
    Returns empty dict if no collections file found.
:::{rubric} Examples
:class: rubric-examples
:::


```python
>>> collections = load_collections(Path("/path/to/project"))
    >>> for name, config in collections.items():
    ...     print(f"{name}: {config.directory}")
    blog: content/blog
    docs: content/docs
```

:::{note}The collections file should export a `collections` dict::::
:::{note}```python # collections.py from dataclasses import dataclass from bengal.collections import define_collection:::
:::{note}@dataclass class BlogPost: title: str ...:::
:::{note}collections = { "blog": define_collection(schema=BlogPost, directory="content/blog"), } ```:::





### `get_collection_for_path`


```python
def get_collection_for_path(file_path: Path, content_root: Path, collections: dict[str, CollectionConfig]) -> tuple[str | None, CollectionConfig | None]
```



Determine which collection a content file belongs to.

Matches the file path against collection directories to find
the applicable collection.


**Parameters:**

| Name | Type | Default | Description |
|:-----|:-----|:--------|:------------|
| `file_path` | `Path` | - | Path to content file |
| `content_root` | `Path` | - | Root content directory |
| `collections` | `dict[str, CollectionConfig]` | - | Dictionary of loaded collections |







**Returns**


`tuple[str | None, CollectionConfig | None]` - Tuple of (collection_name, CollectionConfig) if file is in a collection,
    or (None, None) if file doesn't belong to any collection.
:::{rubric} Examples
:class: rubric-examples
:::


```python
>>> file_path = Path("content/blog/my-post.md")
    >>> name, config = get_collection_for_path(file_path, Path("content"), collections)
    >>> name
    'blog'
```





### `validate_collections_config`


```python
def validate_collections_config(collections: dict[str, CollectionConfig], content_root: Path) -> list[str]
```



Validate collection configurations.

Checks that collection directories exist and are valid.


**Parameters:**

| Name | Type | Default | Description |
|:-----|:-----|:--------|:------------|
| `collections` | `dict[str, CollectionConfig]` | - | Dictionary of loaded collections |
| `content_root` | `Path` | - | Root content directory |







**Returns**


`list[str]` - List of warning messages for invalid configurations.



---
*Generated by Bengal autodoc from `bengal/bengal/collections/loader.py`*

